I designed the database with seven tables to satisfy Third Normal Form and maintain strict referential integrity. Board spaces use a Supertype Subtype structure, with a parent table Locations that holds common attributes and one to one links to child tables Buildings and Specials. This avoids many null values in a single table and guarantees that one space is either a building or a special event, never both. Repeated descriptive values such as tokens and colour groups are moved into lookup tables and referenced by foreign keys, which brings the schema close to BCNF and reduces update anomalies while keeping the design easy to extend.

At the physical level I deliberately used zero based indexing for board locations. Welcome Week is stored as location_id equal to zero and the board runs from zero to nineteen. A new position can then be computed as current_location plus dice_roll modulo twenty, without extra offset logic or correction steps. This keeps the SQL movement statements simple, avoids off by one errors, and stays consistent with common array indexing in programming and data structures.

For gameplay I implemented explicit transaction scripts rather than triggers. All rules are visible inside the scripts and transient states such as the current dice roll are handled directly in the control flow, instead of being hidden in background database objects. Rents and costs are not hard coded but retrieved by subqueries, while where clauses ensure that actions are only applied when the preconditions hold, for example purchases only proceed when owner_id is null. Nested subqueries and case when expressions implement double rent for monopolies, and the COALESCE function protects calculations from null values so that every credit update is numerically stable.

The Leaderboard view keeps raw player names in storage and derives snake case representation only in the view layer using nested LOWER and REPLACE functions. Owned buildings are listed in clockwise order by sorting in a subquery before applying GROUP_CONCAT, since SQLite aggregate functions cannot impose their own order. This ensures that the textual summary of player assets always matches the actual order of locations on the physical board.

To resolve rule ambiguities I allow negative balances and treat them as debt because the brief does not define bankruptcy behaviour or forced selling of properties. Credits can move below zero and are expected to be recovered in later turns. In the conflict in Rule R5, jailing has higher priority than the extra roll on a six, so Stewart’s third round ends immediately after landing in jail and the second roll from the brief is ignored by design. The audit log records these decisions with semantic action_type tags such as TURN_END for normal turns, ROLL_6_NO_EFFECT for moves where a six causes movement but no transaction, and JAILED_TURN_END for the forced end of Stewart’s round after being sent to jail.  These conventions make the simulation consistent, transparent, and easy to audit for correctness.